import { z } from 'zod';
import { InvoiceStatus } from '@prisma/client'; // Assuming InvoiceStatus enum is generated by Prisma

export const FINNISH_VAT_RATES = [25.5, 14, 10, 0] as const;
export type FinnishVatRate = (typeof FINNISH_VAT_RATES)[number];

// Base schema for Invoice Item Input
// This schema might be used for forms directly or as a base for backend validation.
// The `itemId` being `uuid` vs `cuid` needs to be consistent with how InventoryItem IDs are.
// Assuming InventoryItem.id is CUID based on other schemas.
const baseInvoiceItemSchema = z.object({
  itemId: z.string().cuid({ message: "Valid Inventory Item ID is required" }),
  description: z.string().min(1, "Description is required"), // This will likely be autopopulated from item
  quantity: z.number().positive("Quantity must be positive"),
  unitPrice: z.number().nonnegative("Unit price cannot be negative"), // Allow 0 for free items
  vatRatePercent: z.number().min(0).max(100, "VAT rate must be between 0 and 100").default(25.5), // Default to 25.5%
  discountAmount: z.number().nonnegative({ message: 'Discount amount cannot be negative' }).optional().nullable(),
  discountPercent: z.number().min(0).max(100, { message: 'Discount percent must be between 0 and 100' }).optional().nullable(),
  rowFreeText: z.string().optional(), // Additional description/notes for the row
});


// Schema for an invoice item when creating/updating an invoice.
// This will be used in the `items` array of the main invoice schemas.
export const InvoiceItemSchema = baseInvoiceItemSchema.extend({
  id: z.string().cuid().optional(), // ID is optional for new items
  // invoiceId: z.string().cuid().optional(), // Will be set by the backend
});

// Schema for an invoice item when creating an invoice.
export const CreateInvoiceItemSchema = baseInvoiceItemSchema;

// Schema for an invoice item when updating an invoice (includes optional ID).
export const UpdateInvoiceItemSchema = InvoiceItemSchema;

// Schema for creating a new invoice (manual or from order)
export const CreateInvoiceSchema = z.object({
  customerId: z.string().cuid({ message: 'Valid Customer ID is required' }),
  invoiceDate: z.coerce.date({ required_error: 'Invoice date is required' }),
  dueDate: z.coerce.date({ required_error: 'Due date is required' }),
  notes: z.string().nullable().optional(),
  referenceNumber: z.string().nullable().optional(), // Finnish viitenumero - will be auto-generated if not provided
  sellerReference: z.string().nullable().optional(), // Free text field for seller reference
  ourReference: z.string().nullable().optional(),
  customerNumber: z.string().nullable().optional(),
  deliveryMethod: z.string().nullable().optional(),
  deliveryDate: z.coerce.date().nullable().optional(),
  complaintPeriod: z.string().nullable().optional().default("7 vrk"),
  penaltyInterest: z.coerce.number().nullable().optional().default(11.5),
  items: z
    .array(InvoiceItemSchema)
    .min(1, { message: 'Invoice must have at least one item' }),
  orderId: z.string().cuid().optional().nullable(), // Link to originating order
  vatReverseCharge: z.boolean().default(false), // Add vatReverseCharge
  // invoiceNumber, totalAmount, totalVatAmount will be handled backend
});


// Schema for creating an invoice FROM an order specifically
// This might be simpler, primarily taking orderId and dates.
// Items would be derived from the order.
export const createInvoiceFromOrderSchema = z.object({
  orderId: z.string().cuid("Valid Order ID is required"),
  invoiceDate: z.coerce.date().optional().default(() => new Date()),
  dueDate: z.coerce.date({ required_error: "Due date is required"}),
  notes: z.string().optional(),
  referenceNumber: z.string().optional(), // Finnish viitenumero - will be auto-generated if not provided
  sellerReference: z.string().optional(), // Free text field for seller reference
  ourReference: z.string().optional(),
  customerNumber: z.string().optional(),
  deliveryMethod: z.string().optional(),
  deliveryDate: z.coerce.date().optional(),
  complaintPeriod: z.string().optional().default("7 vrk"),
  penaltyInterest: z.coerce.number().optional().default(11.5),
  vatReverseCharge: z.boolean().default(false),
});


// Schema for updating an existing invoice
export const UpdateInvoiceSchema = CreateInvoiceSchema.extend({
  id: z.string().cuid({ message: "Invoice ID is required" }),
  status: z.nativeEnum(InvoiceStatus).optional(), // Allow updating status
}).partial(); // Make all fields optional for update, except ID.

// Schema for updating invoice status
export const updateInvoiceStatusSchema = z.object({
  id: z.string().cuid({ message: "Invoice ID is required" }), // Added ID
  status: z.nativeEnum(InvoiceStatus),
});

// Schema for recording payment
export const recordPaymentSchema = z.object({
  id: z.string().cuid({ message: "Invoice ID is required" }), // Added ID
  paymentDate: z.coerce.date().optional().default(() => new Date()),
});

// Basic filter schema
export const invoiceFilterSchema = z.object({
  customerId: z.string().cuid().optional(),
  status: z.nativeEnum(InvoiceStatus).optional(),
  fromDate: z.coerce.date().optional(),
  toDate: z.coerce.date().optional(),
  searchTerm: z.string().optional(),
  vatReverseCharge: z.boolean().optional(),
}).partial();

// Pagination schema
export const invoicePaginationSchema = z.object({
  page: z.coerce.number().int().positive().optional().default(1),
  perPage: z.coerce.number().int().positive().optional().default(10),
  sortBy: z.string().optional().default('invoiceDate'), // Consider specific sortable fields enum
  sortDirection: z.enum(['asc', 'desc']).optional().default('desc'),
});

// Type inference
export type CreateInvoiceInput = z.infer<typeof CreateInvoiceSchema>;
export type UpdateInvoiceInput = z.infer<typeof UpdateInvoiceSchema>;
export type InvoiceItemInput = z.infer<typeof InvoiceItemSchema>; // For individual items
export type CreateInvoiceFromOrderInput = z.infer<typeof createInvoiceFromOrderSchema>;
export type UpdateInvoiceStatusInput = z.infer<typeof updateInvoiceStatusSchema>;
export type RecordPaymentInput = z.infer<typeof recordPaymentSchema>;

// Type for form data, which might differ slightly (e.g. for useFieldArray key)
// This manual type can be kept for reference or removed if InvoiceFormValues supersedes it.
export type InvoiceFormData = {
  id?: string;
  customerId: string;
  invoiceDate: Date;
  dueDate: Date;
  notes?: string;
  items: {
    key?: string; // For react-hook-form useFieldArray
    id?: string; 
    itemId: string;
    description: string;
    quantity: number;
    unitPrice: number;
    vatRatePercent: FinnishVatRate | number; // Allow number for input flexibility
    discountAmount?: number | null;
    discountPercent?: number | null;
    rowFreeText?: string; // Additional description/notes for the row
  }[];
  orderId?: string | null;
  vatReverseCharge: boolean;
  status?: InvoiceStatus;
};

// NEW: Schema for a single item within the InvoiceForm for client-side validation
export const invoiceFormItemSchema = z.object({
  id: z.string().cuid().optional(), // for existing items if editing
  itemId: z.string({ required_error: "Item must be selected." }).min(1, "Item must be selected."), // Expecting a non-empty string (CUID) from select
  description: z.string({ required_error: "Description is required." }).min(1, "Description is required."), // Auto-populated or user-entered
  quantity: z.number({ required_error: "Quantity is required", invalid_type_error: "Quantity must be a number"}).positive("Quantity must be positive."),
  unitPrice: z.number({ required_error: "Unit price is required", invalid_type_error: "Unit price must be a number"}).nonnegative("Unit price cannot be negative."),
  vatRatePercent: z.number({ required_error: "VAT rate is required", invalid_type_error: "VAT rate must be a number"}).min(0).max(100, "VAT rate must be between 0 and 100"),
  discountAmount: z.number().nonnegative({message: "Discount amount must be non-negative"}).optional().nullable(),
  discountPercent: z.number().min(0, {message: "Discount percent must be between 0 and 100"}).max(100, { message: 'Discount percent must be between 0 and 100' }).optional().nullable(),
  rowFreeText: z.string().optional(), // Additional description/notes for the row
});

// NEW: Schema for the entire InvoiceForm for client-side validation
export const invoiceFormValidationSchema = z.object({
  // id: z.string().cuid().optional(), // Uncomment if using this form for updates and passing ID
  customerId: z.string({ required_error: "Customer is required." }).min(1, "Customer is required."), // Expecting a non-empty string (CUID)
  invoiceDate: z.date({ required_error: "Invoice date is required." }),
  dueDate: z.date({ required_error: "Due date is required." }),
  paymentTermsDays: z.number().optional(), // Payment terms in days
  notes: z.string().optional(),
  referenceNumber: z.string().optional(), // Finnish viitenumero - will be auto-generated if not provided
  sellerReference: z.string().optional(), // Free text field for seller reference
  ourReference: z.string().optional(),
  customerNumber: z.string().optional(),
  deliveryMethod: z.string().optional(),
  deliveryDate: z.date().optional().nullable(), // Delivery date
  complaintPeriod: z.string().optional(),
  penaltyInterest: z.number().optional().nullable(), // Penalty interest rate
  items: z.array(invoiceFormItemSchema).min(1, "Invoice must have at least one item."),
  orderId: z.string().cuid().optional(),
  vatReverseCharge: z.boolean().optional(),
  // status: z.nativeEnum(InvoiceStatus).optional(), // Usually not part of create form data
});

export type InvoiceFormValues = z.infer<typeof invoiceFormValidationSchema>; 