import { z } from 'zod';
import { InvoiceStatus } from '@prisma/client'; // Assuming InvoiceStatus enum is generated by Prisma

// Base schema for Invoice Item Input
const invoiceItemInputSchema = z.object({
  itemId: z.string().uuid("Valid Inventory Item ID is required"),
  description: z.string().min(1, "Description is required"),
  quantity: z.number().positive("Quantity must be positive"),
  unitPrice: z.number().positive("Unit price must be positive"),
  vatRatePercent: z.number().min(0).max(100, "VAT rate must be between 0 and 100"),
  // Optional links - adjust if needed
  // orderItemId: z.string().uuid().optional(),
  // inventoryItemId: z.string().uuid().optional(),
});

// Schema for creating an invoice from an order
export const createInvoiceFromOrderSchema = z.object({
  orderId: z.string().uuid("Valid Order ID is required"),
  invoiceDate: z.coerce.date().optional().default(() => new Date()), // Default to today
  dueDate: z.coerce.date(),
  notes: z.string().optional(),
});

// Schema for creating a manual invoice
export const createManualInvoiceSchema = z.object({
  customerId: z.string().uuid("Valid Customer ID is required"),
  invoiceDate: z.coerce.date().optional().default(() => new Date()),
  dueDate: z.coerce.date(),
  notes: z.string().optional(),
  items: z.array(invoiceItemInputSchema).min(1, "At least one invoice item is required"),
});

// Schema for updating invoice status
export const updateInvoiceStatusSchema = z.object({
  status: z.nativeEnum(InvoiceStatus), // Use Prisma enum here
});

// Schema for recording payment
export const recordPaymentSchema = z.object({
  paymentDate: z.coerce.date().optional().default(() => new Date()),
  // amount: z.number().positive().optional(), // Could add partial payments later
});

// Basic filter schema (expand as needed)
export const invoiceFilterSchema = z.object({
  customerId: z.string().uuid().optional(),
  status: z.nativeEnum(InvoiceStatus).optional(), // Use Prisma enum here
  fromDate: z.coerce.date().optional(),
  toDate: z.coerce.date().optional(),
  searchTerm: z.string().optional(),
}).partial();

// Pagination schema (similar to orders)
export const invoicePaginationSchema = z.object({
  page: z.coerce.number().int().positive().optional().default(1),
  perPage: z.coerce.number().int().positive().optional().default(10),
  sortBy: z.string().optional().default('invoiceDate'),
  sortDirection: z.enum(['asc', 'desc']).optional().default('desc'),
});

// Schema for a single invoice item
export const InvoiceItemSchema = z.object({
  itemId: z.string().cuid({ message: 'Invalid item ID' }), // Link to InventoryItem
  description: z.string().optional(), // Optional override of item name
  quantity: z.number().positive({ message: 'Quantity must be positive' }),
  unitPrice: z.number().nonnegative({ message: 'Unit price cannot be negative' }),
  vatRatePercent: z.number().min(0).max(100, { message: 'VAT rate must be between 0 and 100' }),
});

// Schema for creating a new invoice
export const CreateInvoiceSchema = z.object({
  customerId: z.string().cuid({ message: 'Invalid customer ID' }),
  invoiceDate: z.date({ required_error: 'Invoice date is required' }),
  dueDate: z.date({ required_error: 'Due date is required' }),
  // status will default to DRAFT on the backend
  // invoiceNumber will be generated on the backend
  // totalAmount & totalVatAmount will be calculated on the backend
  notes: z.string().optional(),
  items: z
    .array(InvoiceItemSchema)
    .min(1, { message: 'Invoice must have at least one item' }),
  // Optional: Link to originating order
  orderId: z.string().cuid().optional().nullable(),
});

// Schema for updating an existing invoice (adjust as needed)
export const UpdateInvoiceSchema = CreateInvoiceSchema.extend({
  id: z.string().cuid(),
  status: z.nativeEnum(InvoiceStatus).optional(), // Allow updating status
}).omit({ customerId: true }); // Usually don't change customer on update

export type CreateInvoiceInput = z.infer<typeof CreateInvoiceSchema>;
export type UpdateInvoiceInput = z.infer<typeof UpdateInvoiceSchema>;
export type InvoiceItemInput = z.infer<typeof InvoiceItemSchema>; 