# Tech Stack & Development Patterns - Simplified ERP System

## 1. Core Technologies

- **Framework:** Next.js 14+ (App Router)
- **UI:** React 18+, Shadcn UI, Tailwind CSS
- **Language:** TypeScript 5.x (Strict Mode)
- **State Management:** URL State (`nuqs`), Minimal Zustand
- **Forms:** React Hook Form + Zod
- **Database ORM:** Prisma
- **Database Hosting:** PostgreSQL (e.g., via Supabase, Neon, local)
- **API/Mutations:** tRPC
- **Authentication:** NextAuth.js (with Prisma Adapter)
- **Styling:** Tailwind CSS (with Shadcn presets)
- **Testing:** Vitest (Unit/Integration), React Testing Library, Playwright (E2E - optional)
- **Linting/Formatting:** ESLint, Prettier

## 2. Key Development Patterns

### 2.1. Server Components First
- Default to React Server Components (RSCs) for pages and data-display components.
- Fetch data directly within RSCs or via Server Actions called from RSCs.
- Minimize `'use client'` directive.

### 2.2. Targeted Client Components
- Use Client Components (`'use client'`) only when interactivity is required (event handlers, `useState`, `useEffect`, browser APIs).
- Keep Client Components small and focused. Pass data down from Server Components via props.
- Lift state up only when necessary, or use URL state/minimal Zustand.

### 2.3. Server Actions for Mutations
- Use Server Actions for all data mutations (Create, Update, Delete).
- Define actions in `src/lib/actions/`.
- Ensure actions are secure, perform validation (Zod), handle errors, and return structured responses (e.g., `{ success: boolean, data?: T, error?: { message: string, code?: string } }`).
- Use `revalidatePath` or `revalidateTag` within actions to update cached data and refresh UI.

### 2.3. tRPC for API Layer

- Use tRPC procedures for all API communication (queries and mutations).
- Define routers in `src/lib/api/routers/` and compose them in `src/lib/api/root.ts`.
- Define procedures within routers using `publicProcedure` or `protectedProcedure` (requiring authentication).
- Use Zod for input validation within procedures.
- Handle errors by throwing `TRPCError`.
- Client-side calls use the generated tRPC client (`@/lib/trpc/react`) which integrates with React Query for caching, refetching, etc.

### 2.4. Type Safety
- **TypeScript Strict Mode:** Enable and adhere to strict type checking.
- **Branded Types:** Use for IDs, monetary values, specific string formats (see `02-type-flow-and-finvoice.md`).
- **Zod Validation:** Validate all external inputs (forms, tRPC inputs) rigorously.
- **Database Types:** Use types generated by Prisma Client.
- **Consistent Naming:** PascalCase for types/interfaces, camelCase for variables/functions.

### 2.5. State Management Strategy
- **URL State:** Primary method for client UI state like filters, pagination, sorting (`nuqs` library recommended).
- **Component State:** Use `useState` for local component interactivity.
- **Server State:** Managed via tRPC queries and React Query's cache.
- **Global Client State (Zustand):** Use *sparingly* only for truly global UI concerns not tied to server data (e.g., toast notifications, theme toggle, sidebar state). Avoid storing server-fetched data here.

### 2.6. Error Handling
- **Server Actions:** Return structured error objects. Consider Railway Oriented Programming (Result types) for robust error flow.
- **UI:** Use React Error Boundaries for unexpected rendering errors. Display user-friendly messages (e.g., Shadcn `Toast` or `Alert`) based on errors returned from Server Actions.
- **tRPC Procedures:** Throw `TRPCError` within procedures for expected API errors.
- **UI:** Use React Error Boundaries. Handle tRPC errors using React Query's `onError` callbacks or hook states. Display user-friendly messages (e.g., Shadcn `Toast`).
- **Logging:** Implement basic console logging; consider integrating a service like Sentry for production.

### 2.7. Functional Programming & Immutability
- Prefer pure functions where possible.
- Avoid direct state mutation; use functional updates (`setState(prev => ...)`, immutable array/object updates).
- Break down logic into smaller, composable functions.

### 2.8. Styling & UI
- **Shadcn UI:** Leverage pre-built components. Customize via props and Tailwind classes.
- **Tailwind CSS:** Use utility classes for styling. Configure `tailwind.config.js` for the monochrome theme (black/white/grays).
- **Responsiveness:** Design mobile-first using Tailwind's responsive modifiers.
- **Accessibility:** Follow accessibility best practices (semantic HTML, ARIA attributes where needed).

### 2.9. Testing Strategy
- **Unit Tests (Vitest):** Test utility functions, complex logic within components/actions, Zustand stores (if used).
- **Integration Tests (Vitest/RTL):** Test tRPC procedures (mocking Prisma client), interactions between components and tRPC hooks/mutations.
- **E2E Tests (Playwright - Optional):** Simulate user flows across multiple pages/modules.
- **Colocation:** Place test files (`*.test.ts(x)`) alongside the code they test.
- **Mocking:** Use Vitest's mocking capabilities for dependencies (DB, external APIs).

### 2.10. Finvoice Generation
- Isolate Finvoice XML generation logic in a dedicated service (`src/lib/services/finvoice.service.ts`).
- Use a reliable XML builder library.
- Map internal types carefully to the Finvoice 3.0 (Netvisor) schema.
- Retrieve Seller Party configuration potentially via a dedicated tRPC query.

## 3. Bug Resistance Recommendations

- **Strong Typing & Validation:** The most critical aspect. Be rigorous with TypeScript and Zod at all boundaries.
- **Immutability:** Reduces side effects and makes state changes predictable.
- **Pure Functions:** Easier to test and reason about.
- **tRPC with Strong Typing & Validation:** Centralizes API logic and makes communication type-safe.
- **Minimal Client State:** Reduces complexity and potential state synchronization issues.
- **Comprehensive Testing:** Catch regressions and validate logic.
- **Code Reviews:** Ensure adherence to patterns and catch potential issues early.
- **Principle of Least Privilege (RLS):** While Prisma doesn't use Supabase RLS directly, ensure application logic enforces necessary authorization checks, potentially within tRPC procedures or middleware.

**Note:** This project will commence using a pre-configured Next.js starter template (e.g., `next-ai-starter` or similar), providing a base setup for Next.js, TypeScript, Tailwind, Shadcn UI, and Supabase integration.
**Note:** This project uses a foundation based on Next.js, TypeScript, Tailwind, Shadcn UI, Prisma, and NextAuth. tRPC is used for the API layer.

## 7. Background Jobs & Tasks

- **Inngest:** Used for handling asynchronous tasks or potentially long-running operations (e.g., complex report generation, external API calls). See `inngest.config.ts` and `src/app/api/inngest/route.ts`.
- **Polling:** UI updates based on Inngest events should use polling mechanisms rather than relying directly on tRPC mutation success for background job completion status.

## 8. Performance Considerations

- **Database Indexing:** Add indexes in `prisma/schema.prisma` for frequently queried, filtered, or sorted fields.
- **React Query Caching:** Leverage default tRPC/React Query caching. Use `placeholderData: keepPreviousData` for smooth pagination/updates. Adjust `staleTime` for specific queries where applicable.
- **Next.js Caching:** Utilize Server Component data caching. Use route segment `revalidate` options for controlling data freshness.
- **Prefetching:** Use `<Link prefetch={true}>` for common navigation paths. Consider `queryClient.prefetchQuery` in list views for likely detail view navigations.
- **Bundle Size:** Monitor bundle size using `@next/bundle-analyzer` as complexity grows.

## 9. PDF Generation

- **Strategy:** Server-side generation using a library like Puppeteer is preferred for control and performance.
- **Implementation:** Likely triggered via a tRPC mutation calling an Inngest function or a dedicated API route that performs the generation and returns the file.
- **Templates:** Requires HTML/CSS templates designed for PDF output.

## 10. Code Quality & Standards

- **TypeScript:** Strict mode, avoid `any`, use utility types.
- **ESLint/Prettier:** Enforce consistent code style and catch potential errors.
- **Naming Conventions:** PascalCase for components/types, camelCase for variables/functions, snake_case for DB tables/fields.
- **Modularity:** Organize code by feature/domain within `/src/app`, `/src/components`, `/src/lib`.
- **Reusability:** Place shared logic in `src/lib/utils.ts` or feature-specific utility files.
- **Error Handling:** Consistent error handling in tRPC procedures and UI components.
