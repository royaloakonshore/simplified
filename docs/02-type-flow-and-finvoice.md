# Type Flow and Finvoice Integration

## 1. Core Principles

- **TypeScript Strict Mode:** Enforce maximum type safety.
- **Branded Types:** Use branded types for better domain modeling and preventing accidental misuse of primitive types (e.g., `UUID`, `Decimal`, `DateString`, `CurrencyCode`).
- **Zod Schemas:** Define Zod schemas for validation at boundaries (forms, API inputs, Server Actions).
- **Database Types:** Leverage Supabase CLI to generate types from the database schema for type-safe database interactions.
- **Clear Boundaries:** Be explicit about type conversions between layers (UI <-> Server Action <-> Database <-> Finvoice).

## 2. Branded Types (Example)

Located in `src/lib/types/common.types.ts`:

```typescript
declare const __uuidBrand: unique symbol;
type UUIDBrand = { [__uuidBrand]: void };
export type UUID = string & UUIDBrand;
export function toUUID(value: string): UUID {
  // Add validation if needed (e.g., regex check for UUID format)
  if (!isValidUUID(value)) {
      throw new Error(`Invalid UUID format: ${value}`);
  }
  return value as UUID;
}

declare const __decimalBrand: unique symbol;
type DecimalBrand = { [__decimalBrand]: void };
export type Decimal = number & DecimalBrand; // Or use a library like decimal.js
export function toDecimal(value: number | string): Decimal {
  // Add validation/conversion logic
  const num = typeof value === 'string' ? parseFloat(value) : value;
  if (isNaN(num)) {
      throw new Error(`Invalid Decimal value: ${value}`);
  }
  // Consider precision requirements
  return num as Decimal;
}

// Similar definitions for DateString (ISO 8601), CurrencyCode (ISO 4217)
```

## 3. Type Layers & Conversions

1.  **UI Layer (React Components):**
    *   Uses types defined in `src/lib/types/` for props and state.
    *   Form data often corresponds to Zod schemas (`src/lib/schemas/`).
    *   Displays formatted data (e.g., dates, currency) using utilities from `src/lib/utils.ts`.

2.  **Action/API Layer (Server Actions, API Routes):**
    *   Receives input, validates using Zod schemas.
    *   Converts validated schema data to internal domain types (`src/lib/types/`) or database types.
    *   Calls database functions.
    *   Converts database results back to domain types if necessary before returning to UI.

3.  **Database Layer (`src/lib/db.ts`, Supabase):**
    *   Uses types generated by `supabase gen types typescript`.
    *   Functions interacting with the DB expect/return these generated types.
    *   Conversion functions might be needed to map between domain types and DB types if they differ significantly (e.g., `Date` vs. `timestamp with time zone`).

4.  **Finvoice Export Layer (`src/lib/services/finvoice.service.ts`):**
    *   Takes internal domain types (e.g., `Invoice`, `Customer`, `InvoiceItem[]` from `src/lib/types/`) as input.
    *   Maps these types to the structure required by the Finvoice 3.0 XML schema (Netvisor variant).
    *   Uses an XML builder library (e.g., `xmlbuilder2`) to generate the final XML string.

## 4. Finvoice 3.0 / Netvisor Mapping Strategy (Option B)

Internal data models (`Customer`, `Invoice`, `InvoiceItem`, etc. in `src/lib/types/`) will be designed to be comprehensive for the ERP's needs while ensuring all data *required* by the Netvisor Finvoice 3.0 import specification can be derived or directly mapped.

**Key Principles:**

*   **Required Fields:** Internal types MUST include fields that directly correspond to mandatory Finvoice fields (e.g., `InvoiceNumber`, `InvoiceDate`, `BuyerPartyDetails`, `InvoiceLine` details).
*   **Optional Fields:** Internal types MAY include additional fields for internal use.
*   **Mapping Logic:** A dedicated service (`src/lib/services/finvoice.service.ts`) will contain the mapping logic.
*   **Data Sources:** Data for the Finvoice XML will be sourced primarily from the `Invoice` object and its related `Customer`, `Order` (if linked), and `InvoiceItem` data.
*   **Configuration:** Seller party details (company name, VAT ID, bank details, etc.) needed for the Finvoice header should be configurable within the application (e.g., in Settings) and retrieved during export.

**Example Mapping (`Customer` to `BuyerPartyDetails`):**

*   **Internal `Customer` Type (`src/lib/types/customer.types.ts`):**
    ```typescript
    interface Customer extends Auditable {
      id: UUID;
      name: string;
      vatId?: string; // Business ID / Y-tunnus
      email?: string;
      phone?: string;
      isBusiness: boolean;
      // Internal fields...
      addresses: Address[];
      // Finvoice relevant identifiers
      ovtIdentifier?: string; // EDI / OVT-tunnus
      intermediatorAddress?: string; // Välittäjän osoite
    }

    interface Address {
       id: UUID;
       streetAddress: string;
       postalCode: string;
       city: string;
       countryCode: string; // e.g., 'FI'
       type: 'billing' | 'shipping';
    }
    ```
*   **Finvoice `BuyerPartyDetails` Mapping (Conceptual in `finvoice.service.ts`):**
    ```typescript
    function mapCustomerToBuyerParty(customer: Customer, billingAddress: Address) {
      return {
        BuyerPartyIdentifier: customer.vatId, // VAT ID
        BuyerOrganisationName: [customer.name],
        BuyerOrganisationDepartment: [], // Optional
        BuyerOrganisationTaxCode: customer.vatId,
        BuyerCode: customer.ovtIdentifier, // OVT/EDI
        BuyerPostalAddressDetails: {
          BuyerStreetName: [billingAddress.streetAddress],
          BuyerTownName: [billingAddress.city],
          BuyerPostCodeIdentifier: [billingAddress.postalCode],
          CountryCode: [billingAddress.countryCode],
          CountryName: [''] // Usually not needed if Code provided
        }
      };
    }
    ```

**Mapping Considerations:**

*   **Identifiers:** Ensure `vatId` (Y-tunnus) and `ovtIdentifier` (OVT/EDI) are captured correctly for business customers.
*   **Addresses:** Map the correct address (usually billing) to `BuyerPostalAddressDetails`.
*   **Line Items:** Map `InvoiceItem` details (`description`, `quantity`, `unitPrice`, `unitCode`, `vatRatePercent`) precisely to `InvoiceLine` elements.
    *   Requires internal `InventoryItem` to have `unitCode` (e.g., 'kpl', 'h').
    *   Requires `vatRatePercent` on line items.
    *   **Discounts:** Discounts applied to `InvoiceItem` (`discountAmount` or calculated from `discountPercentage`) should be reflected in the `InvoiceLine` structure, potentially using `LineDiscountAmount` or adjusting `LineBaseAmount` according to Finvoice specs.
*   **Payment Details:** Map invoice `dueDate`, `invoiceTotal` (incl./excl. VAT), bank details (from settings) to `PaymentTermsDetails` and `InvoiceRecipientDetails`.
*   **VAT Reverse Charge:** If the `Invoice.vatReverseCharge` flag is `true`:
    *   All line item `vatRatePercent` values sent in the XML should be `0`.
    *   A specific VAT exemption reason code/text needs to be included. Consult Finvoice 3.0 specification (Section 5.17 VatSpecificationDetails) for the appropriate `VatExemptionReasonCode` or `VatExemptionReasonText` (e.g., Code "VATRC" for Reverse Charge might be applicable, or specific Finnish codes).
    *   This likely involves adding conditional logic within `finvoice.service.ts` to populate `<VatSpecificationDetails>` elements correctly when the flag is active.

**References:**

*   [Finvoice 3.0 Implementation Guidelines](https://file.finanssiala.fi/finvoice/Finvoice_3_0_implementation_guidelines.pdf)
*   [Netvisor Finvoice Import](https://support.netvisor.fi/en/support/solutions/articles/77000498451-finvoice-import)

## 5. Type Generation

- Use `npx supabase gen types typescript --project-id <your-project-ref> --schema public > src/lib/types/supabase.ts` to generate database types.
- Keep manually defined domain types (`src/lib/types/*.types.ts`) separate from generated Supabase types.
